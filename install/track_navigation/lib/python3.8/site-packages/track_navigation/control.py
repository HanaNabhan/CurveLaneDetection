import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Float32
import numpy as np
import math

"""
Lidar Lane Follower Node for Autonomous Driving
-------------------------------------------------
LiDAR-based lane-following algorithm for autonomous vehicles using ROS 2. 

Author: Hana Nabhan
"""
class LaneCurveDetection(Node):
    def __init__(self):
        super().__init__('lidar_lane_follower')

        # LiDAR subscription
        self.subscription = self.create_subscription(
            LaserScan,
            '/autodrive/f1tenth_1/lidar',
            self.lidar_callback,
            10
        )

        # Publishers for steering and throttle
        self.steering_pub = self.create_publisher(Float32, '/autodrive/f1tenth_1/steering_command', 10)
        self.throttle_pub = self.create_publisher(Float32, '/autodrive/f1tenth_1/throttle_command', 10)

        # Lane detection parameters
        self.lane_detection_range = 5.0  # Maximum range for lane detection
        self.min_points_for_fit = 10  # Minimum number of points needed for polynomial fitting
        self.poly_degree = 2  # Degree of polynomial for fitting
        self.max_steering_angle = 1.0  # Maximum steering angle in radians

    def lidar_callback(self, msg: LaserScan):
        # Extract LiDAR data
        ranges = np.array(msg.ranges)
        angles = np.linspace(msg.angle_min, msg.angle_max, len(ranges))

        # Filter valid points
        valid_mask = (ranges > 0.1) & (ranges < self.lane_detection_range)
        ranges = ranges[valid_mask]
        angles = angles[valid_mask]

        # Convert polar to Cartesian coordinates
        x = ranges * np.cos(angles)
        y = ranges * np.sin(angles)

        # Separate points into left and right lanes
        # Separate points into left and right lanes based on their y-coordinate
# Points with positive y-values are on the left side of the car
        left_points = np.array([
            (xi, yi)            # Create a pair (xi, yi) for each point
            for xi, yi in zip(x, y)  # Combine x and y coordinates into pairs
            if yi > 0           # Only include points where y > 0 (left side)
        ])
        
        # Points with negative y-values are on the right side of the car
        right_points = np.array([
            (xi, yi)            # Create a pair (xi, yi) for each point
            for xi, yi in zip(x, y)  # Combine x and y coordinates into pairs
            if yi < 0           # Only include points where y < 0 (right side)
        ])


        # Fit polynomials to left and right lanes
        left_poly = self.fit_polynomial(left_points)
        right_poly = self.fit_polynomial(right_points)

        # Control vehicle based on fitted polynomials
        steering_angle, throttle = self.control_vehicle(left_poly, right_poly)

        # Publish commands
        self.steering_pub.publish(Float32(data=steering_angle))
        self.throttle_pub.publish(Float32(data=throttle))

    def fit_polynomial(self, points):
        """Fit a polynomial to the given points if enough points are available."""
        if points.shape[0] < self.min_points_for_fit:
            return None  # Not enough points for a fit
        x, y = points[:, 0], points[:, 1]
        return np.poly1d(np.polyfit(x, y, self.poly_degree))

    def control_vehicle(self, left_poly, right_poly):
       """Calculate steering angle and throttle based on lane polynomials."""
       target_distance = 2.0  # Distance ahead to calculate lane center

       is_straight_lane = False  # Flag to detect straight lanes

       if left_poly and right_poly:
           # Calculate lane center at the target distance
           left_y = left_poly(target_distance)
           right_y = right_poly(target_distance)
           lane_center_y = (left_y + right_y) / 2

           # Check if the lane is straight by comparing polynomial curvature
           # For a straight line, the quadratic term (highest degree) should be close to zero
           if abs(left_poly.c[0]) < 0.1 and abs(right_poly.c[0]) < 0.1:
               is_straight_lane = True

           # Calculate steering angle toward the lane center
           steering_angle = math.atan2(lane_center_y, target_distance)

           # Adjust throttle based on lane type
           throttle = 0.18 if is_straight_lane else 0.122
       elif left_poly:
           # Steer toward the left lane if only the left lane is visible
           steering_angle = math.atan2(left_poly(target_distance), target_distance)
           throttle = 0.1
       elif right_poly:
           # Steer toward the right lane if only the right lane is visible
           steering_angle = math.atan2(right_poly(target_distance), target_distance)
           throttle = 0.1
       else:
           # Default behavior if no lanes are visible
           steering_angle = 0.0
           throttle = 0.1

       # Limit the steering angle
       steering_angle = np.clip(steering_angle, -self.max_steering_angle, self.max_steering_angle)
       return steering_angle, throttle


def main(args=None):
    rclpy.init(args=args)
    lidar_lane_follower = LaneCurveDetection()

    try:
        rclpy.spin(lidar_lane_follower)
    except KeyboardInterrupt:
        pass

    lidar_lane_follower.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
